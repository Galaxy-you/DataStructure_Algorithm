# 排序

![image-20251016103307268](./assert/image-20251016103307268.png)

* 基数排序：桶排序的扩展

## 算法-时间复杂度

![image-20251016105150288](./assert/image-20251016105150288.png)

忽略常数项，忽略低次项，忽略系数（看情况吧，有的时候系数还是比较重要的，不过如果是O复杂度确实可以忽略系数）

![image-20251016111244586](./assert/image-20251016111244586.png)

**O(n!)**的时间复杂度最大。

![image-20251016111918796](./assert/image-20251016111918796.png)

## 常用排序算法总结和对比

![image-20251016112048659](./assert/image-20251016112048659.png)

![image-20251017153310131](./assert/image-20251017153310131.png)

* 希尔排序的空间复杂度为O(1)，且不需要用到递归（栈）

## 空间复杂度

![image-20251016112903489](./assert/image-20251016112903489.png)



## 创建数组的方法

**标注数组（使用 [ ] ）**

* int[] array = {1,2,3}; // 使用{}进行初始化
* int[] array = new int[]{1,2,3}; // 使用new关键字配合使用{}
* int[] array = new int[5];  // 先创建再赋值

**ArrayList（动态数组）**

* ArrayList list = new ArrayList(); // 不指定类型（不推荐）
* ArrayList<Integer> list = new ArrayList(); // 使用泛型（推荐）
* ArrayList<Integer> list = new ArrayList(20);  // 指定初始容量

常用方法：

* add(elem)	add(index,elem)
* get(index)
* size()
* isEmpty()
* contains(elem) => boolean
* indexOf(elem) => index: int
* set(index,newElem)
* remove(index)     remove(elem)
* clear()



## 插入排序

![image-20251016143751606](./assert/image-20251016143751606.png)

### 直接插入排序

![image-20251016143920669](./assert/image-20251016143920669.png)



### 希尔排序

希尔排序也叫缩小增量排序，是一种分组插入排序。

![image-20251016153907168](./assert/image-20251016153907168.png)

插入时可以采用交换法或者移动法

#### 交换法

#### 移动法







## 选择排序

![image-20251016140708861](./assert/image-20251016140708861.png)

### 简单选择排序

![image-20251016140846630](./assert/image-20251016140846630.png)![image-20251016141329655](./assert/image-20251016141329655.png)



### 堆排序

![image-20251025143848346](./assert/image-20251025143848346.png)

堆分为大顶堆和小顶堆。

![image-20251025144107398](./assert/image-20251025144107398.png)

![image-20251025144222092](./assert/image-20251025144222092.png)

利用**顺序存储二叉树**，将完全二叉树转变为**数组**，所以堆排序中不需要实际用到树这种结构。

**堆排序的步骤**

![image-20251025144946978](./assert/image-20251025144946978.png)![image-20251025145000547](./assert/image-20251025145000547.png)

大顶堆：从小到大顺序排序。小顶堆：逆序



## 交换排序

### 冒泡排序

![image-20251016113626329](./assert/image-20251016113626329.png)



### 快速排序

![image-20251017081340148](./assert/image-20251017081340148.png)

## 归并排序

![image-20251017104004767](./assert/image-20251017104004767.png)

![image-20251017111540083](./assert/image-20251017111540083.png)

## 基数排序

![image-20251017135416904](./assert/image-20251017135416904.png)

每一次重新放入桶中，可以保证 比当前正在排列的位数低 的那些位数在一个桶中是有序的。

* 第一轮按照个位数字进行排序，然后依次从各个“桶”中取出

![image-20251017135848567](./assert/image-20251017135848567.png)

* 第二轮按照十位数进行排序，然后依次从各个“桶”中取出

![image-20251017140047276](./assert/image-20251017140047276.png)

* 第三轮

![image-20251017140436111](./assert/image-20251017140436111.png)
